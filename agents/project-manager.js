/**
 * Project Manager Agent
 * Workflow orchestration using Asana and Notion for campaign lifecycle management
 * 
 * Responsibilities:
 * - Campaign brief creation and tracking
 * - Task assignment and deadline management
 * - Documentation and knowledge base updates
 * - Cross-functional coordination
 * - Status reporting and escalations
 */

const name = 'Project Manager';
const role = 'project-manager';
const description = 'Project management agent for campaign workflows, task coordination, and documentation using Asana and Notion';
const model = 'claude-3-5-sonnet-20241022'; // Requires complex reasoning for prioritization

const capabilities = [
  'task_management',
  'brief_creation',
  'workflow_orchestration',
  'documentation',
  'deadline_tracking',
  'status_reporting',
  'escalation_handling',
  'meeting_notes'
];

const tools = [
  'connectors.asana',
  'connectors.notion',
  'connectors.ttd',
  'connectors.dv360',
  'connectors.amazon-dsp'
];

const systemPrompt = `You are the Project Manager agent for Ad Ops Command Center.

Your role is to coordinate campaign workflows and ensure timely delivery:

**Asana Integration:**
- Create and manage campaign brief tasks
- Track creative approval workflows
- Monitor pacing alerts and issue resolution
- Assign tasks and manage deadlines
- Facilitate cross-team coordination

**Notion Integration:**
- Maintain campaign playbooks and SOPs
- Update vendor documentation
- Capture meeting notes and action items
- Build and curate the knowledge base

**Key Workflows:**
1. Campaign Kickoff: Create briefs, assign tasks, set milestones
2. Creative Approval: Track review status, manage feedback loops
3. Launch Preparation: Coordinate setup tasks across teams
4. Issue Resolution: Escalate blockers, track resolution
5. Wrap-up: Document learnings, update playbooks

**Communication Style:**
- Clear and actionable task descriptions
- Proactive deadline reminders
- Structured status updates
- Escalate blockers early

Always prioritize critical-path items and ensure nothing falls through the cracks.`;

/**
 * Get agent info
 */
function getInfo() {
  return {
    name,
    role,
    description,
    model,
    capabilities,
    tools
  };
}

/**
 * Create campaign brief in Asana
 */
async function createCampaignBrief(campaignData, asanaConnector) {
  const {
    campaignName,
    lob,
    channel,
    funnel,
    budget,
    startDate,
    endDate,
    objectives,
    targetAudience,
    kpis,
    assignee
  } = campaignData;
  
  const notes = `**Campaign Brief**

**Campaign Name:** ${campaignName}
**Line of Business:** ${lob}
**Channel:** ${channel}
**Funnel Stage:** ${funnel}

**Budget:** $${budget.toLocaleString()}
**Flight Dates:** ${startDate} to ${endDate}

**Objectives:**
${objectives.map(o => `- ${o}`).join('\n')}

**Target Audience:**
${targetAudience}

**KPIs:**
${kpis.map(k => `- ${k}`).join('\n')}

---
*Created by Ad Ops Command Center*`;

  const task = await asanaConnector.handleToolCall('asana_create_task', {
    name: `Campaign Brief: ${campaignName}`,
    project_id: 'proj-001', // Q1 2026 Campaign Launches
    section_id: 'sec-001', // Briefing section
    assignee,
    due_on: calculateBriefDueDate(startDate, 10), // 10 days before launch
    notes
  });
  
  // Create subtasks for key deliverables
  const subtasks = [
    { name: 'Creative brief approved', due_offset: -7 },
    { name: 'Targeting strategy finalized', due_offset: -6 },
    { name: 'Budget allocation confirmed', due_offset: -5 },
    { name: 'Tracking/pixels verified', due_offset: -3 },
    { name: 'DSP campaigns set up', due_offset: -2 }
  ];
  
  return {
    brief: task.data,
    message: `Campaign brief created for ${campaignName}`,
    nextSteps: subtasks.map(s => s.name)
  };
}

/**
 * Create pacing alert task
 */
async function createPacingAlert(pacingData, asanaConnector) {
  const {
    campaignId,
    campaignName,
    dsp,
    variance,
    expectedSpend,
    actualSpend,
    recommendedActions
  } = pacingData;
  
  const severity = Math.abs(variance) > 20 ? 'CRITICAL' : 'WARNING';
  const gap = expectedSpend - actualSpend;
  
  const notes = `**Automated Pacing Alert**

**Campaign:** ${campaignName} (${campaignId})
**DSP:** ${dsp.toUpperCase()}
**Pacing Status:** ${variance > 0 ? 'AHEAD' : 'BEHIND'} by ${Math.abs(variance).toFixed(1)}%

**Expected Spend:** $${expectedSpend.toLocaleString()}
**Actual Spend:** $${actualSpend.toLocaleString()}
**Gap:** $${Math.abs(gap).toLocaleString()}

**Recommended Actions:**
${recommendedActions.map((a, i) => `${i + 1}. ${a}`).join('\n')}

---
*Generated by Ad Ops Command Center at ${new Date().toISOString()}*`;

  const task = await asanaConnector.handleToolCall('asana_create_task', {
    name: `${severity} PACING ALERT: ${campaignName} ${variance > 0 ? 'ahead' : 'behind'} ${Math.abs(variance).toFixed(0)}%`,
    project_id: 'proj-003', // Pacing Alerts project
    section_id: 'sec-020', // New Alerts section
    due_on: new Date().toISOString().split('T')[0], // Due today
    notes
  });
  
  return {
    alert: task.data,
    severity,
    message: `Pacing alert created for ${campaignName}`
  };
}

/**
 * Update campaign status in Notion
 */
async function updateCampaignStatus(campaignId, status, notionConnector) {
  // Query the campaign tracker database
  const campaigns = await notionConnector.handleToolCall('notion_query_database', {
    database_id: 'db-001'
  });
  
  // Find the campaign
  const campaign = campaigns.results.find(c => {
    const title = c.properties['Campaign Name']?.title?.[0]?.text?.content;
    return title?.includes(campaignId) || c.id === campaignId;
  });
  
  if (!campaign) {
    throw new Error(`Campaign not found: ${campaignId}`);
  }
  
  // Update the status
  const updated = await notionConnector.handleToolCall('notion_update_page', {
    page_id: campaign.id,
    properties: {
      'Status': { select: { name: status } }
    }
  });
  
  return {
    campaign: updated,
    message: `Campaign status updated to ${status}`
  };
}

/**
 * Create meeting notes in Notion
 */
async function createMeetingNotes(meetingData, notionConnector) {
  const {
    title,
    date,
    attendees,
    agendaItems,
    discussionPoints,
    actionItems
  } = meetingData;
  
  const content = [
    { type: 'heading_1', content: title },
    { type: 'paragraph', content: `**Date:** ${date}` },
    { type: 'paragraph', content: `**Attendees:** ${attendees.join(', ')}` },
    { type: 'heading_2', content: 'Agenda' },
    ...agendaItems.map(item => ({ type: 'bulleted_list_item', content: item })),
    { type: 'heading_2', content: 'Discussion' },
    ...discussionPoints.map(point => ({ type: 'paragraph', content: point })),
    { type: 'heading_2', content: 'Action Items' },
    ...actionItems.map(item => ({ 
      type: 'to_do', 
      content: `${item.task} â€” @${item.owner} â€” Due: ${item.dueDate}` 
    }))
  ];
  
  const page = await notionConnector.handleToolCall('notion_create_page', {
    parent_id: 'db-003', // Meeting Notes database
    parent_type: 'database_id',
    title,
    content
  });
  
  // Create corresponding Asana tasks for action items
  return {
    page,
    actionItemCount: actionItems.length,
    message: `Meeting notes created with ${actionItems.length} action items`
  };
}

/**
 * Get workflow status summary
 */
async function getWorkflowStatus(projectId, asanaConnector) {
  const project = await asanaConnector.handleToolCall('asana_get_project', {
    project_id: projectId
  });
  
  const tasks = await asanaConnector.handleToolCall('asana_list_tasks', {
    project_id: projectId,
    completed: false
  });
  
  // Categorize tasks by section/status
  const bySection = {};
  for (const task of tasks.data) {
    const section = task.memberships?.[0]?.section?.name || 'Uncategorized';
    if (!bySection[section]) {
      bySection[section] = [];
    }
    bySection[section].push(task);
  }
  
  // Find overdue tasks
  const today = new Date().toISOString().split('T')[0];
  const overdue = tasks.data.filter(t => t.due_on && t.due_on < today);
  
  // Find tasks due soon (within 3 days)
  const threeDaysOut = new Date();
  threeDaysOut.setDate(threeDaysOut.getDate() + 3);
  const dueSoon = tasks.data.filter(t => {
    if (!t.due_on) return false;
    return t.due_on >= today && t.due_on <= threeDaysOut.toISOString().split('T')[0];
  });
  
  return {
    project: {
      id: project.data.gid,
      name: project.data.name,
      taskCount: project.data.task_count,
      incompleteCount: project.data.incomplete_task_count
    },
    sections: Object.entries(bySection).map(([name, tasks]) => ({
      name,
      taskCount: tasks.length
    })),
    alerts: {
      overdue: overdue.map(t => ({ id: t.gid, name: t.name, dueOn: t.due_on })),
      dueSoon: dueSoon.map(t => ({ id: t.gid, name: t.name, dueOn: t.due_on }))
    },
    summary: `${project.data.incomplete_task_count} open tasks, ${overdue.length} overdue, ${dueSoon.length} due within 3 days`
  };
}

/**
 * Escalate blocker
 */
async function escalateBlocker(blockerData, asanaConnector) {
  const {
    taskId,
    reason,
    impact,
    escalateTo,
    requestedResolution
  } = blockerData;
  
  // Add comment to the task
  await asanaConnector.handleToolCall('asana_add_comment', {
    task_id: taskId,
    text: `ðŸš¨ **ESCALATION**

**Reason:** ${reason}
**Impact:** ${impact}
**Requested Resolution:** ${requestedResolution}
**Escalated To:** @${escalateTo}

*Please review and respond urgently.*`
  });
  
  // Update task to mark as blocked
  await asanaConnector.handleToolCall('asana_update_task', {
    task_id: taskId,
    name: `[BLOCKED] ${blockerData.originalName || 'Task'}`
  });
  
  return {
    message: `Blocker escalated to ${escalateTo}`,
    taskId
  };
}

/**
 * Search knowledge base in Notion
 */
async function searchKnowledgeBase(query, notionConnector) {
  const results = await notionConnector.handleToolCall('notion_search', {
    query,
    sort: { direction: 'descending', timestamp: 'last_edited_time' }
  });
  
  return {
    results: results.results.map(r => ({
      id: r.id,
      type: r.object,
      title: r.properties?.title?.title?.[0]?.text?.content || r.title?.[0]?.text?.content,
      lastEdited: r.last_edited_time,
      url: r.url
    })),
    count: results.results.length,
    query
  };
}

/**
 * Process natural language query
 */
async function processQuery(query, context = {}) {
  const q = query.toLowerCase();
  
  // Task/workflow queries
  if (q.includes('status') || q.includes('workflow') || q.includes('project')) {
    return {
      message: 'I can provide workflow status. Which project would you like to check?',
      action: 'get_workflow_status',
      availableProjects: ['Q1 2026 Campaign Launches', 'Galaxy S25 Launch Campaign', 'Pacing Alerts']
    };
  }
  
  // Brief creation
  if (q.includes('brief') || q.includes('new campaign')) {
    return {
      message: 'I can create a campaign brief. Please provide the campaign details.',
      action: 'create_brief',
      requiredFields: ['campaignName', 'lob', 'channel', 'funnel', 'budget', 'startDate', 'endDate']
    };
  }
  
  // Alert creation
  if (q.includes('alert') || q.includes('pacing')) {
    return {
      message: 'I can create pacing alerts for campaigns that need attention.',
      action: 'create_alert'
    };
  }
  
  // Documentation search
  if (q.includes('search') || q.includes('find') || q.includes('documentation') || q.includes('sop')) {
    return {
      message: 'What would you like to search for in the knowledge base?',
      action: 'search_knowledge_base'
    };
  }
  
  // Meeting notes
  if (q.includes('meeting') || q.includes('notes')) {
    return {
      message: 'I can create or find meeting notes. Would you like to create new notes or search existing ones?',
      action: 'meeting_notes'
    };
  }
  
  return {
    message: 'I manage campaign workflows and documentation. I can help with briefs, task tracking, status updates, and knowledge base searches.',
    capabilities
  };
}

// Helper functions
function calculateBriefDueDate(launchDate, daysBefore) {
  const launch = new Date(launchDate);
  launch.setDate(launch.getDate() - daysBefore);
  return launch.toISOString().split('T')[0];
}

module.exports = {
  name,
  role,
  description,
  model,
  capabilities,
  tools,
  systemPrompt,
  getInfo,
  createCampaignBrief,
  createPacingAlert,
  updateCampaignStatus,
  createMeetingNotes,
  getWorkflowStatus,
  escalateBlocker,
  searchKnowledgeBase,
  processQuery
};
